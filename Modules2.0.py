# -*- coding: utf-8 -*-
"""
Created on Thu Dec  1 18:40:20 2022

@author: Fjodor

"""

# PrimerPair class
class PrimerPair:
    def __init__(self, GeneName, LeftPrimer, LeftPrimer_AllInfo, RightPrimer, RightPrimer_AllInfo, OtherInfo):
        self.GeneName = GeneName
        self.LeftPrimer = LeftPrimer
        self.LeftPrimer_AllInfo = LeftPrimer_AllInfo
        self.RightPrimer = RightPrimer
        self.RightPrimer_AllInfo = RightPrimer_AllInfo
        self.RCoRP = RightPrimer.reverse_complement()
        self.OtherInfo = OtherInfo
    MotifIndex = 0
    ActualMotifLength = 0
    ActualMotif = ""
    LPScore = 0
    RCoRPScore = 0  

    def __str__(self):
        return f"Left primer: {self.LeftPrimer} ({self.LeftPrimer_AllInfo}) Right primer: {self.RightPrimer} ({self.RightPrimer_AllInfo}) "

# Advanced search, 
def advancedsearch(motif, target): 
    '''
    Inputs are the motif (what you're searching for) and the target (what you're searching in) 
    Outputs are a list with the index, length of the actually found sequence, and the sequence itself

    Parameters
    ----------
    motif : string
        what you're searching for.
    target : string
        what you're searching in.

    Returns
    -------
    Result : list
        First item of the list is the index of the starting nucleotide, second item is the length of the sequence in the alignment
        third is the redifined match (including - for spacing).

    '''
    import re
    count = 0
    index = 0
    ActualLength = 0
    ActualMatch = ""
    splitstring = ""
    for i in motif : 
        splitstring += i + "\-*"   
    for match in re.finditer(splitstring, target):
        count += 1
        # Getting results: "Number of matches", count, match.group(), "start index", match.start(), "end index", match.end())
        index = match.start()
        ActualLength = len(match.group())
        ActualMatch = match.group()
    Result = [index, ActualLength, ActualMatch]
    return Result

def ScoringFuntion(Primer, Sequence) :
    OverlapScore = 0
    for i in range(len(Sequence)) :
        if Sequence[i] == "-" :
            continue
        elif Sequence[i] == Primer[i] :
            OverlapScore += 1
    return OverlapScore


def Primer3Parser(Primer3Output) :
    '''
    Parser for the Primer3 output
    Input is the name of the output file: "Primer3Output.txt", function returns a list with all the primer pairs

    Parameters
    ----------
    Primer3Output : STRING
        Filename of the txt file with in it the complete autput as generated by Primer3.

    Returns
    -------
    PrimerList : LIST
        List of all primer pairs that were suggested by Primer3.

    '''
    from Bio.Seq import Seq
    #First the gene name is grabed from the file:
    with open(Primer3Output) as f:
        Alllines = f.readlines()
        nameline = Alllines[1]
        GeneName = nameline[27: -2]
    
    # Then, the file is opened once more (this time read line by line) to grab each of the primer pairs:
    FindRightLines = -1 # Starting value until "LEFT PRIMER" is found
    RightPrimerLineFound = False
    PrimerNumber = 0    # Allows for counting primers, necessary for naming, dictionary
    LeftPrimersList = []
    RightPrimersList = []
    LeftPrimer_AllInfoList = []
    RightPrimer_AllInfoList = []
    OtherInfoList = []
    with open(Primer3Output) as f:
        for line in f:
            if RightPrimerLineFound == True :
                OtherInfo = line
                OtherInfoList.append(OtherInfo)
                FindRightLines = -1
                RightPrimerLineFound = False
            if FindRightLines != -1:                                 # find "the" right lines
                RightPrimer = Seq(line[FindRightLines+56: ])
                RightPrimersList.append(RightPrimer)
                RightPrimer_AllInfo = line
                RightPrimer_AllInfoList.append(RightPrimer_AllInfo)
                RightPrimerLineFound = True
            FindRightLines = line.find("LEFT PRIMER")
            if FindRightLines != -1 : 
                LeftPrimer = Seq(line[FindRightLines+56: ])
                LeftPrimer_AllInfo = line
                LeftPrimer_AllInfoList.append(LeftPrimer_AllInfo)
                PrimerNumber = PrimerNumber +1
                LeftPrimersList.append(LeftPrimer)
    # Lastly, the primer pairs are saved as primer pair class items in a dictionary with the key being formatted in the form of "PrimerPair_1"
    # The value includes all information as well as the sequences
    
    PrimerList = []
    for i in range(PrimerNumber) :
        Primer = PrimerPair(GeneName, LeftPrimersList[i], LeftPrimer_AllInfoList[i], RightPrimersList[i], RightPrimer_AllInfoList[i], OtherInfoList[i])
        PrimerList.append(Primer)
    return PrimerList



def FastaAlignmentParser(Alignment):
    '''
    Takes a fasta alignment and parses it into a dictionary to be used by SearchFunction
    Creates searchable alignment (Dictionary of strings with each gene as an item in the dicitonary and each sequences as a list, gene name is the key)        
    To get aligned file: make Clustal W alignment in MEGA11 based on the CDS sequences (from vaccinium.org), export alignment as fasta

    Parameters
    ----------
    Alignment : string
        Name of the fasta alignment file.
        Alignment made using ClustalW in MEGA11

    Returns
    -------
    AlignmentDict : DICTIONARY
        Returns a dictionary used by SearchFunction.

    '''
    
    AlignmentDict = {}
    SequenceFound = False
    GeneNameAlignment = "PlaceholderUntilFirstNameisFound"
    with open(Alignment) as f:
        for line in f:
            if SequenceFound == True :
                AlignmentDict[GeneNameAlignment] = line
                SequenceFound = False
            if line[0] == ">" : 
                SequenceFound = True
                GeneNameAlignment = line[1:-2]
    return AlignmentDict


def SelectionFunction(PrimerList, AlignmentDictionary, Primer):
    '''
    Search funciton: Goes through a list of primer pairs, and checks each of them using the scoring function.
    If a primer is good enough, the primerpair is added to the returned list

    Parameters
    ----------
    PrimerList : LIST
        List as made by Primer3Parser with all primer pairs.
    AlignmentDictionary : Dictionary
        Dictionary as formatted by AlignmentParser.
    Primer : STRING
        Either "Left" or "Right".

    Returns
    -------
    SelectedPrimers : LIST
        List with the primers that made it through the selection.

    '''
    # SearchFunction takes a list with primers (primer pair class), an Alignment as parsed by the alignmentparser and either "Left" or "Right"
    # Output: A dictionary with all the primers that passed the test
    SelectedPrimers = []
    # Checking all left primers of primer pairs on all sequences
    for PrimerPair in PrimerList :
        searchingsequence = str(AlignmentDictionary[PrimerPair.GeneName])
        if Primer == "Left" :
            searchmotif = str(PrimerPair.LeftPrimer)
            searchmotif = searchmotif.rstrip(searchmotif[-1])
        elif Primer == "Right" : 
            searchmotif = str(PrimerPair.RCoRP)
            searchmotif = searchmotif[1:]
        else :
            print("Incorrect primername was entered. type 'Left' or 'Right'")
            
        AdvancedSearchResult = advancedsearch(searchmotif, searchingsequence)
        PrimerPair.MotifIndex = AdvancedSearchResult[0]
        PrimerPair.ActualMotifLength = AdvancedSearchResult[1]
        PrimerPair.ActualMotif = AdvancedSearchResult[2]
        #print(PrimerPair.MotifIndex, PrimerPair.LeftPrimer, PrimerPair.ActualMotif)
        ScoreList = [] # Elements of eventual dictionary
        for gene in AlignmentDictionary :
            SearchBegin = PrimerPair.MotifIndex
            SearchEnd = SearchBegin + PrimerPair.ActualMotifLength
            WholeGeneSequence = AlignmentDictionary[gene]
            SearchRegion = WholeGeneSequence[SearchBegin:SearchEnd]
            Score = ScoringFuntion(PrimerPair.ActualMotif, SearchRegion)
            ScoreList.append(Score) 
        ScoreList.sort()
        if ScoreList[-2] < 17 :
            # Out of all genes, the second highest score lower than 17
            SelectedPrimers.append(PrimerPair)
            if Primer == "Left" :
                PrimerPair.LPScore = ScoreList[-2]
            else : 
                PrimerPair.RCoRPScore = ScoreList[-2]
            #print(f"Selected primer, {PrimerPair} was added to the list, its score was: {ScoreList}, actual motif: {PrimerPair.ActualMotif}")            
    return SelectedPrimers

def SaveSelectedPrimers(SelectedPrimerPairList, GeneName, FileName = "PrimerResults.txt") :
    '''
    Saves the list of selected primers to a .txt file named "PrimerResults.txt", by default
    Running the function requires:
    

    Parameters
    ----------
    SelectedPrimerPairList : LIST
        List with items of PrimerPair class that are to be saved as a .txt file

    Returns
    -------
    Either "Succes" or "Failed"

    '''
    if len(SelectedPrimerPairList) == 0 :
        print("No suitable primers were found, please increase the parameters of the primer search and try again.")
        # print(f"The number of primers that were checked is: {len(ParsedPrimerList)}")
        # print(f"The number of LEFT primers that made it through is: {len(SelectedLeftPrimers)}")
        # print(f"That took {Duration} seconds!")
        Succes = "Failed"
    else: 
        print(f'{len(SelectedPrimerPairList)} Primer(s) were found. Results saved to "PrimerResults.txt"')
        with open(FileName, "w") as f :
            f.write(f"The following primers were found for {GeneName}: \n")
            for i in SelectedPrimerPairList :
                f.write(f"{i.LeftPrimer_AllInfo} Score: {i.LPScore}\n")
                f.write(f"{i.RightPrimer_AllInfo} Score: {i.RCoRPScore}\n")
                f.write(f"{i.OtherInfo}\n")
        Succes = "Succes"
    return Succes


def ScoringFunction(Primer, Sequence) :
    OverlapList = []
    for i in range(len(Sequence)) :
        if Sequence[i] == "-" :
            continue
        elif Sequence[i] == Primer[i] :
            OverlapList.append(0)
        else :
            OverlapList.append(1)
    return OverlapList


def SelectionFunction2(PrimerList, AlignmentDictionary, Primer, RunDoubleAnalysis = True):
    '''
    Search funciton: Goes through a list of primer pairs, and checks each of them using the scoring function.
    If a primer is good enough, the primerpair is added to the returned list

    Parameters
    ----------
    PrimerList : LIST
        List as made by Primer3Parser with all primer pairs.
    AlignmentDictionary : Dictionary
        Dictionary as formatted by AlignmentParser.
    Primer : STRING
        Either "Left" or "Right".
    RunDoubleAnalysis : Boolean (True/False)
        Either True or False

    Returns
    -------
    SelectedPrimers : LIST
        List with the primers that made it through the selection.

    '''
    # SearchFunction takes a list with primers (primer pair class), an Alignment as parsed by the alignmentparser and either "Left" or "Right"
    # Output: A dictionary with all the primers that passed the test
    SelectedPrimers = []
    # Checking all left primers of primer pairs on all sequences
    for PrimerPair in PrimerList :
        searchingsequence = str(AlignmentDictionary[PrimerPair.GeneName])
        if Primer == "Left" :
            searchmotif = str(PrimerPair.LeftPrimer)
            searchmotif = searchmotif.rstrip(searchmotif[-1])
        elif Primer == "Right" : 
            searchmotif = str(PrimerPair.RCoRP)
            searchmotif = searchmotif[1:]
        else :
            print("Incorrect primername was entered. type 'Left' or 'Right'")
            
        AdvancedSearchResult = advancedsearch(searchmotif, searchingsequence)
        PrimerPair.MotifIndex = AdvancedSearchResult[0]
        PrimerPair.ActualMotifLength = AdvancedSearchResult[1]
        PrimerPair.ActualMotif = AdvancedSearchResult[2]
        #print(PrimerPair.MotifIndex, PrimerPair.LeftPrimer, PrimerPair.ActualMotif)
        PrimerFailed = False # PrimerFailed starts False, turns to True if the primer has significant overlap with any of the other genes
        for gene in AlignmentDictionary :
            SearchBegin = PrimerPair.MotifIndex
            SearchEnd = SearchBegin + PrimerPair.ActualMotifLength
            WholeGeneSequence = AlignmentDictionary[gene]
            SearchRegion = WholeGeneSequence[SearchBegin:SearchEnd] 
            
            OverlapList = ScoringFunction(PrimerPair.ActualMotif, SearchRegion)
            
            if len(OverlapList) == 0 or sum(OverlapList) == 0 : #Skip all "-" sequences and the primer sequence
                continue
            if RunDoubleAnalysis == True: 
                if (sum(OverlapList[-6 : ])) < 3 :                # Selection criteria 1: Out of the last 6 nucleotides, no more than 2 can overlap
                    PrimerFailed = True
                    break
            if sum(OverlapList) < (0.25 *len(OverlapList)) :      # Selection criteria 2: A maximum overlap of 25% is set
                PrimerFailed = True
                break   
        if PrimerFailed == False :
            SelectedPrimers.append(PrimerPair)
    return SelectedPrimers

